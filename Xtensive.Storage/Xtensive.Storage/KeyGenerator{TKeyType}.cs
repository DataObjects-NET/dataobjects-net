// Copyright (C) 2009 Xtensive LLC.
// All rights reserved.
// For conditions of distribution and use, see license.
// Created by: Alexis Kochetov
// Created:    2009.11.18

using System;
using Xtensive.Core;
using Xtensive.Core.Arithmetic;
using Xtensive.Core.Comparison;
using Xtensive.Core.Tuples;
using Xtensive.Storage.Model;
using Xtensive.Storage.Providers;
using Xtensive.Storage.Resources;

namespace Xtensive.Storage
{
  /// <summary>
  /// Default <see cref="KeyGenerator"/> implementation.
  /// </summary>
  /// <typeparam name="TKeyType">The type of the key field.</typeparam>
  public class KeyGenerator<TKeyType> : KeyGenerator
  {
    private const string DefaultTemporaryStringKeyPrefix = "@=";
    private static readonly Type fieldType = typeof (TKeyType);

    private string temporaryStringKeyPrefix = DefaultTemporaryStringKeyPrefix;
    private readonly object syncRoot = new object();
    private Tuple tuplePrototype;
    private TKeyType lastTemporary;
    private TKeyType last;
    private Arithmetic<TKeyType> arithmetic;
    private AdvancedComparer<TKeyType> comparer;

    /// <exception cref="NotSupportedException">Already initialized.</exception>
    public string TemporaryStringKeyPrefix {
      get { return temporaryStringKeyPrefix; }
      set {
        if (temporaryStringKeyPrefix!=DefaultTemporaryStringKeyPrefix)
          throw Exceptions.AlreadyInitialized("TemporaryStringKeyPrefix");
        temporaryStringKeyPrefix = value;
      }
    }

    /// <inheritdoc/>
    public override long? SequenceIncrement { 
      get { return null; }
    }

    /// <summary>
    /// Gets the sync root used to serialize key generation.
    /// </summary>
    protected object SyncRoot {
      get { return syncRoot; }
    }

    /// <summary>
    /// Gets the tuple prototype for this key generator.
    /// </summary>
    protected Tuple TuplePrototype {
      get { return tuplePrototype; }
    }

    /// <summary>
    /// Gets the arithmetic for <typeparamref name="TKeyType"/>, if available.
    /// </summary>
    public Arithmetic<TKeyType> Arithmetic {
      get { return arithmetic; }
    }

    /// <summary>
    /// Gets the advanced comparer for <typeparamref name="TKeyType"/>, if available.
    /// </summary>
    public AdvancedComparer<TKeyType> Comparer {
      get { return comparer; }
    }

    /// <inheritdoc/>
    /// <exception cref="NotSupportedException">Unsupported key field type.</exception>
    public override bool IsTemporaryKey(Tuple key) 
    {
      var value = key.GetValue<TKeyType>(0);
      if (arithmetic!=null) {
        if (arithmetic.IsSigned)
          return comparer.Compare(arithmetic.Zero, value) > 0;
        else {
          var maxSigned = arithmetic.Divide(arithmetic.MaxValue, 2);
          return comparer.Compare(maxSigned, value) < 0;
        }
      }
      else {
        if (fieldType==typeof(Guid)) {
          var bytes = ((Guid) (object) value).ToByteArray();
          ulong highULong = BitConverter.ToUInt64(bytes, 8);
          return highULong==0;
        }
        if (fieldType==typeof (string))
          return ((string) (object) value).StartsWith(TemporaryStringKeyPrefix);
        throw new NotSupportedException(
          Strings.ExSpecifiedKeyFieldTypeIsNotSupportedByThisTemporaryKeyGenerator);
      }
    }


    /// <inheritdoc/>
    /// <exception cref="NotImplementedException">Non-temporary keys must be 
    /// generated by descendants.</exception>
    public override Tuple Next(bool temporaryKey)
    {
      return DefaultNext(temporaryKey);
    }

    /// <summary>
    /// Default <see cref="Next"/> method implementation.
    /// </summary>
    /// <param name="temporaryKey">If set to <see langword="true"/>, a temporary key must be created.</param>
    /// <returns>Generated key;
    /// <see langword="null" />, if required key can not be generated.</returns>
    protected Tuple DefaultNext(bool temporaryKey)
    {
      var result = tuplePrototype.CreateNew();
      lock (syncRoot) {
        if (!temporaryKey) {
          last = GetNextValue(last);
          result.SetValue(0, last);
          return result;
        }
        else {
          lastTemporary = GetNextTemporaryValue(lastTemporary);
          result.SetValue(0, lastTemporary);
          return result;
        }
      }
    }

    /// <exception cref="NotSupportedException">Unsupported key field type.</exception>
    private TKeyType GetNextValue(TKeyType currentValue)
    {
      if (arithmetic!=null)
        return arithmetic.Add(currentValue, arithmetic.One);
      else {
        if (fieldType==typeof(Guid))
          return (TKeyType) (object) Guid.NewGuid();
        if (fieldType==typeof(string))
          return (TKeyType) (object) Guid.NewGuid().ToString();
        throw new NotSupportedException(
          Strings.ExSpecifiedKeyFieldTypeIsNotSupportedByThisTemporaryKeyGenerator);
      }
    }

    /// <exception cref="NotSupportedException">Unsupported key field type.</exception>
    private TKeyType GetNextTemporaryValue(TKeyType currentValue)
    {
      if (arithmetic!=null)
        return arithmetic.Subtract(currentValue, arithmetic.One);
      else {
        if (fieldType==typeof(Guid)) {
          var bytes = ((Guid) (object) lastTemporary).ToByteArray();
          ulong lowULong = BitConverter.ToUInt64(bytes, 0);
          unchecked { lowULong += 1; }
          BitConverter.GetBytes(lowULong).Copy(bytes, 0);
          return (TKeyType) (object) new Guid(bytes);
        }
        if (fieldType==typeof(string)) {
          string strValue = (string) (object) currentValue;
          strValue = strValue.TryCutPrefix(TemporaryStringKeyPrefix);
          long longValue = long.Parse(strValue);
          longValue--;
          return (TKeyType) (object) (TemporaryStringKeyPrefix + longValue);
        }
        throw new NotSupportedException(
          Strings.ExSpecifiedKeyFieldTypeIsNotSupportedByThisTemporaryKeyGenerator);
      }
    }


    /// <inheritdoc/>
    protected internal override void Initialize(HandlerAccessor handlers, KeyProviderInfo keyProviderInfo)
    {
      base.Initialize(handlers, keyProviderInfo);
      tuplePrototype = Tuple.Create(keyProviderInfo.KeyTupleDescriptor);
      arithmetic = Arithmetic<TKeyType>.Default;
      if (arithmetic!=null)
        arithmetic = arithmetic.ApplyRules(
          new ArithmeticRules(NullBehavior.ThreatNullAsNull, OverflowBehavior.AllowOverflow));
      comparer = AdvancedComparer<TKeyType>.Default;
      if (arithmetic!=null)
        lastTemporary = arithmetic.Zero;
      else {
        if (fieldType==typeof (Guid))
          lastTemporary = (TKeyType) (object) Guid.Empty;
        else if (fieldType==typeof (string))
          lastTemporary = (TKeyType) (object) (TemporaryStringKeyPrefix + "0");
      }
      last = lastTemporary;
    }


    // Constructors

    /// <inheritdoc/>
    public KeyGenerator()
    {
    }
  }
}