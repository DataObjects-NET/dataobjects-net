// Copyright (C) 2009 Xtensive LLC.
// All rights reserved.
// For conditions of distribution and use, see license.
// Created by: Ivan Galkin
// Created:    2009.05.07

using System;
using System.Linq;
using Xtensive.Sql;
using Xtensive.Sql.Model;
using Xtensive.Storage.Model;
using Xtensive.Storage.Providers.Sql.Resources;

namespace Xtensive.Storage.Providers.Sql
{
  /// <summary>
  /// Generator factory.
  /// </summary>
  public class KeyGeneratorFactory : Providers.KeyGeneratorFactory
  {
    /// <inheritdoc/>
    public override bool IsSchemaBoundGenerator(GeneratorInfo generatorInfo)
    {
      if (generatorInfo.KeyGeneratorType!=typeof (KeyGenerator))
        return false;
      var generatorTypeCode = Type.GetTypeCode(generatorInfo.TupleDescriptor[0]);
      return generatorTypeCode==TypeCode.SByte
        || generatorTypeCode==TypeCode.Byte
        || generatorTypeCode==TypeCode.Int16
        || generatorTypeCode==TypeCode.UInt16
        || generatorTypeCode==TypeCode.Int32
        || generatorTypeCode==TypeCode.UInt32
        || generatorTypeCode==TypeCode.Int64
        || generatorTypeCode==TypeCode.UInt64;
    }

    protected override KeyGenerator CreateGenerator<TFieldType>(GeneratorInfo generatorInfo)
    {
      var domainHandler = (DomainHandler) Handlers.DomainHandler;
      var valueType = domainHandler.ValueTypeMapper.BuildSqlValueType(generatorInfo.TupleDescriptor[0], null);
      var sqlNext = GetNextValueStatement(
        domainHandler.Driver, generatorInfo.MappingName, domainHandler.Schema, valueType);
      return new SqlCachingKeyGenerator<TFieldType>(generatorInfo, sqlNext);
    }

    internal static ISqlCompileUnit GetNextValueStatement(SqlDriver driver,
      string generatorMappingName, Schema schema, SqlValueType valueType)
    {
      if (driver.ServerInfo.Sequence!=null)
        return GetSequenceBasedNext(generatorMappingName, schema, valueType);
      if (driver.ServerInfo.Identity!=null)
        return GetAutoIncrementColumnBasedNext(generatorMappingName, schema, valueType);
      throw new NotSupportedException();
    }

    private static ISqlCompileUnit GetSequenceBasedNext(
      string generatorMappingName, Schema schema, SqlValueType valueType)
    {
      var sequence = schema.Sequences
        .FirstOrDefault(s => s.Name==generatorMappingName);
      if (sequence==null)
        throw new DomainBuilderException(
          string.Format(Strings.ExSequenceXIsNotFoundInStorage, generatorMappingName));
      return SqlDml.Select(SqlDml.Cast(SqlDml.NextValue(sequence), valueType));
    }

    private static ISqlCompileUnit GetAutoIncrementColumnBasedNext(
      string generatorMappingName, Schema schema, SqlValueType valueType)
    {
      var generatorTable = schema.Tables
        .FirstOrDefault(t => t.Name==generatorMappingName);
      if (generatorTable==null)
        throw new DomainBuilderException(
          string.Format(Strings.ExTableXIsNotFound, generatorMappingName));
      var generatorColumn = generatorTable.Columns
        .FirstOrDefault(c => c.Name==WellKnown.GeneratorColumnName) as TableColumn;
      if (generatorColumn==null)
        throw new DomainBuilderException(
          string.Format(Strings.ExColumnXIsNotFoundInTableY, WellKnown.GeneratorColumnName, generatorTable.Name));
      var result = SqlDml.Batch();
      result.Add(SqlDml.Insert(SqlDml.TableRef(generatorTable)));
      result.Add(SqlDml.Select(SqlDml.Cast(SqlDml.LastAutoGeneratedId(), valueType)));
      return result;
    }
  }
}