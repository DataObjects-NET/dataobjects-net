// Copyright (C) 2009 Xtensive LLC.
// All rights reserved.
// For conditions of distribution and use, see license.
// Created by: Ivan Galkin
// Created:    2009.05.07

using System;
using System.Linq;
using Xtensive.Sql;
using Xtensive.Sql.Model;
using Xtensive.Storage.Model;
using Xtensive.Storage.Providers.Sql.Resources;

namespace Xtensive.Storage.Providers.Sql
{
  /// <summary>
  /// Generator factory.
  /// </summary>
  public class KeyGeneratorFactory : Providers.KeyGeneratorFactory
  {
    /// <inheritdoc/>
    public override bool IsSchemaBoundGenerator(KeyProviderInfo keyProviderInfo)
    {
      if (keyProviderInfo.KeyGeneratorType!=typeof (KeyGenerator))
        return false;
      var generatorTypeCode = Type.GetTypeCode(keyProviderInfo.TupleDescriptor[0]);
      return generatorTypeCode==TypeCode.SByte
        || generatorTypeCode==TypeCode.Byte
        || generatorTypeCode==TypeCode.Int16
        || generatorTypeCode==TypeCode.UInt16
        || generatorTypeCode==TypeCode.Int32
        || generatorTypeCode==TypeCode.UInt32
        || generatorTypeCode==TypeCode.Int64
        || generatorTypeCode==TypeCode.UInt64;
    }

    protected override KeyGenerator CreateGenerator<TFieldType>(KeyProviderInfo keyProviderInfo)
    {
      var domainHandler = (DomainHandler) Handlers.DomainHandler;
      var sqlNext = GetNextValueStatement(domainHandler.ProviderInfo, domainHandler.Schema, keyProviderInfo.MappingName);
      return new SqlCachingKeyGenerator<TFieldType>(keyProviderInfo, sqlNext);
    }

    internal static ISqlCompileUnit GetNextValueStatement(ProviderInfo providerInfo, Schema schema, string generatorMappingName)
    {
      if (providerInfo.Supports(ProviderFeatures.Sequences))
        return GetSequenceBasedNext(providerInfo, schema, generatorMappingName);
      else
        return GetAutoIncrementColumnBasedNext(providerInfo, schema, generatorMappingName);
    }

    private static ISqlCompileUnit GetSequenceBasedNext(ProviderInfo providerInfo, Schema schema, string generatorMappingName)
    {
      var sequence = schema.Sequences
        .FirstOrDefault(s => s.Name==generatorMappingName);
      if (sequence==null)
        throw new DomainBuilderException(
          string.Format(Strings.ExSequenceXIsNotFoundInStorage, generatorMappingName));
      return SqlDml.Select(SqlDml.NextValue(sequence));
    }

    private static ISqlCompileUnit GetAutoIncrementColumnBasedNext(ProviderInfo providerInfo, Schema schema, string generatorMappingName)
    {
      var table = schema.Tables
        .FirstOrDefault(t => t.Name==generatorMappingName);
      if (table==null)
        throw new DomainBuilderException(
          string.Format(Strings.ExTableXIsNotFound, generatorMappingName));

      var idColumn = table.Columns
        .FirstOrDefault(c => c.Name==WellKnown.GeneratorColumnName) as TableColumn;
      if (idColumn==null)
        throw new DomainBuilderException(
          string.Format(Strings.ExColumnXIsNotFoundInTableY, WellKnown.GeneratorColumnName, table.Name));

      var tableRef = SqlDml.TableRef(table);
      var insert = SqlDml.Insert(tableRef);

      if (!providerInfo.Supports(ProviderFeatures.InsertDefaultValues)) {
        var fakeColumn = table.Columns
          .FirstOrDefault(c => c.Name==WellKnown.GeneratorFakeColumnName) as TableColumn;
        if (fakeColumn==null)
          throw new DomainBuilderException(
            string.Format(Strings.ExColumnXIsNotFoundInTableY, WellKnown.GeneratorFakeColumnName, table.Name));
        insert.Values[tableRef[fakeColumn.Name]] = SqlDml.Null;
      }

      var result = SqlDml.Batch();
      result.Add(insert);
      result.Add(SqlDml.Select(SqlDml.LastAutoGeneratedId()));
      return result;
    }
  }
}