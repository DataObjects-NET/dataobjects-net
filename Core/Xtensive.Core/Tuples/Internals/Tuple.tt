<#@ template language="C#" debug="true" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ Assembly Name="System" #>
<#@ Assembly Name="System.Core" #>
<#@ Assembly Name="System.Xml" #>
<#@ Assembly Name="System.Xml.Linq" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<# const int TupleCount = 32; #>
// Copyright (C) 2010 Xtensive LLC.
// All rights reserved.
// For conditions of distribution and use, see license.
// Created by: Alexis Kochetov
// Created:    2010.03.18

using System;
using System.Reflection;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace Xtensive.Tuples.Internals
{
  /// <summary>
  /// Provides access to maximal generated tuple length value.
  /// </summary>
  public static class MaxGeneratedTupleLength
  {
    /// <summary>
    /// Defines maximal generated tuple length value.
    /// The value is <see langword="<#= TupleCount #>" />.
    /// </summary>
    public const int Value = <#= TupleCount #>;
  }

<# for (int i = 0; i < TupleCount; i++) { #>
  /// <summary>
  /// Describes tuple of length <#= i+1 #>.
  /// </summary>
  [DataContract]
  [Serializable]
  public sealed class Tuple<#= GetGenericArgumentsString(i + 1) #> : RegularTuple
  {
    private const int count = <#= i+1 #>;
  
<# for (int j = 0; j <= i; j++) { #>
    /// <summary>
    /// Value number <#= j #>.
    /// </summary>
    [DataMember]
    public T<#= j #> Value<#= j #>;
  
<# } #>
    /// <summary>
    /// Nullability and availability map..
    /// </summary>
    [DataMember]
    public long Flags;

    /// <inheritdoc/>
    public override int Count
    {
      get { return count; }
    }

    /// <inheritdoc/>
    public override Tuple CreateNew()
    {
      return new Tuple<#= GetGenericArgumentsString(i + 1) #>(descriptor);
    }

    /// <inheritdoc/>
    public override Tuple Clone()
    {
      return new Tuple<#= GetGenericArgumentsString(i + 1) #>(this);
    }

    /// <inheritdoc/>
    public override TupleFieldState GetFieldState(int fieldIndex)
    {
      if (fieldIndex < 0 || fieldIndex >= count)
        throw new ArgumentOutOfRangeException("fieldIndex");
      var intValue = (int)((Flags >> (fieldIndex << 1)) & 3);
      return (TupleFieldState) intValue;
    }

    /// <inheritdoc/>
    protected internal override void SetFieldState(int fieldIndex, TupleFieldState fieldState)
    {
      if (fieldIndex < 0 || fieldIndex >= count)
        throw new ArgumentOutOfRangeException("fieldIndex");
      var longValue = (long)fieldState;
      var mask = 3L << (fieldIndex << 1);
      Flags = (Flags & ~mask) | (longValue << (fieldIndex << 1));
    }

    /// <inheritdoc/>
    public override object GetValue(int fieldIndex, out TupleFieldState fieldState)
    {
      fieldState = GetFieldState(fieldIndex);
      switch(fieldIndex) {
<# for (int j = 0; j <= i; j++) { #>
        case <#= j #>:
          return Value<#= j #>;
<# } #>
      }
      throw new ArgumentOutOfRangeException("fieldIndex");
    }

    /// <inheritdoc/>
    public override void SetValue(int fieldIndex, object fieldValue)
    {
      if (fieldIndex < 0 || fieldIndex >= count)
        throw new ArgumentOutOfRangeException("fieldIndex");

      var mask = 3L << (fieldIndex << 1);
      if (fieldValue == null) {
        Flags |= mask;
        switch (fieldIndex) {
<# for (int j = 0; j <= i; j++) { #>
          case <#= j #>:
            Value<#= j #> = default(T<#= j #>);
            break;
<# } #>
        }
      }
      else {
        Flags = (Flags & ~mask) | (1L << (fieldIndex << 1));
        switch (fieldIndex) {
<# for (int j = 0; j <= i; j++) { #>
          case <#= j #>:
            Value<#= j #> = (T<#= j #>)fieldValue;
            break;
<# } #>
        }
      }
    }

<# for (int j = 0; j <= i; j++) { #>
    /// <summary>
    /// Gets the value and state of field <#= j #>.
    /// </summary>
    /// <param name="tuple">The tuple to get field value and state for.</param>
    /// <param name="fieldIndex">Index of the field to use.</param>
    /// <param name="fieldState">Field state associated with the field.</param>
    /// <returns>Field value, if it is available; otherwise, default value for field type.</returns>
    public static T<#= j #> GetValue<#= j #>(Tuple tuple, int fieldIndex, out TupleFieldState fieldState)
    {
      var t = (Tuple<#= GetGenericArgumentsString(i + 1) #>)tuple;
      fieldState = (TupleFieldState) ((t.Flags >> (<#= j #> << 1)) & 3);
      return t.Value<#= j #>;
    }
<# } #>

<# for (int j = 0; j <= i; j++) { #>
    /// <summary>
    /// Sets the value of field <#= j #>.
    /// </summary>
    /// <param name="tuple">The tuple to set field value for.</param>
    /// <param name="fieldIndex">Index of the field to use.</param>
    /// <param name="value">The value to set.</param>
    public static void SetValue<#= j #>(Tuple tuple, int fieldIndex, T<#= j #> value)
    {
      var t = (Tuple<#= GetGenericArgumentsString(i + 1) #>)tuple;
      const long mask = 3L << (<#= j #> << 1);
      if (value == null) 
        t.Flags |= mask;
      else
        t.Flags = (t.Flags & ~mask) | (1L << (<#= j #> << 1));
      t.Value<#= j #> = value;
    }
<# } #>

    /// <inheritdoc/>
    public override bool Equals(Tuple other)
    {
      if (other == null)
        return false;
      var tuple = other as Tuple<#= GetGenericArgumentsString(i + 1) #>;
      if (tuple == null)
        return base.Equals(other);
      if (Flags != tuple.Flags)
        return false;
<# for (int j = i; j >= 0; j--) { #>
      if (!EqualityComparer<T<#= j #>>.Default.Equals(Value<#= j #>, tuple.Value<#= j #>))
        return false;
<# } #>
      return true;
    }
  
    /// <inheritdoc/>
    public override int GetHashCode()
    {
      int result = 0;
<# for (int j = 0; j <= i; j++) { #>
      result = HashCodeMultiplier * result ^ EqualityComparer<T<#= j #>>.Default.GetHashCode(Value<#= j #>);
<# } #>
      return result;
    }

    [OnDeserialized]
    private void OnDeserialized(StreamingContext context)
    {
      descriptor = TupleDescriptor.Create(new[] {
<# for (int j = 0; j <= i; j++) { #>
        typeof (T<#= j #>)<#= j==i ? "" : "," #>
<# } #>
      });
    }


    // Constructors

    /// <inheritdoc/>
    public Tuple(TupleDescriptor descriptor)
      : base(descriptor)
    {
    }

    private Tuple(Tuple<#= GetGenericArgumentsString(i + 1) #> template)
      : base(template.descriptor)
    {
<# for (int j = 0; j <= i; j++) { #>
      Value<#= j #> = template.Value<#= j #>;
<# } #>
      Flags = template.Flags;
    }
  }
  
<# } #>
  internal static class TupleFactory
  {
    public static RegularTuple Create(TupleDescriptor descriptor)
    {
      var fieldCount = descriptor.Count;
      if (fieldCount < 0)
        throw new ArgumentOutOfRangeException("fieldCount");
      if (fieldCount > MaxGeneratedTupleLength.Value) {
        var firstDescriptor = descriptor.Head(MaxGeneratedTupleLength.Value);
        var secondDescriptor = descriptor.Tail(fieldCount - MaxGeneratedTupleLength.Value);
        if (firstDescriptor == null || secondDescriptor == null)
          throw new InvalidOperationException();
        return new JoinedTuple(descriptor, Create(firstDescriptor), Create(secondDescriptor));
      }
      if (fieldCount == 0)
        return EmptyTuple.Instance;
      Type tupleDef = null;
      switch (fieldCount) {
<# for (int i = 1; i <= TupleCount; i++) { #>
        case <#= i #>:
          tupleDef = typeof(Tuple<#= GetGenericTemplateString(i) #>);
          break;
<# } #>
      }
      var tupleType = tupleDef.MakeGenericType(descriptor.fieldTypes);
      return (RegularTuple)Activator.CreateInstance(tupleType, BindingFlags.CreateInstance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance, null, new object[]{descriptor}, null);
    }
  }
}
<#+
  string GetGenericArgumentsString(int count) {
    return PackSequence("<", ">", ",", Enumerable.Range(0, count).Select(i => "T"+i));
  }

  string GetGenericTemplateString(int count) {
    return PackSequence("<", ">", ",", Enumerable.Range(0, count).Select(i => " "));
  }

  string PackSequence(string prologue, string epilogue, string delimiter, IEnumerable<string> items)
  {
    var builder = new StringBuilder();
    if (prologue != null)
      builder.Append(prologue);
    foreach (var item in items) {
      if (builder.Length > prologue.Length)
        builder.Append(delimiter);
      builder.Append(item);
    }
    if (epilogue != null)
      builder.Append(epilogue);
    return builder.ToString();
  }
#>
