// Copyright (C) 2003-2010 Xtensive LLC.
// All rights reserved.
// For conditions of distribution and use, see license.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using Xtensive.Core;
using Xtensive.Sql.Compiler;
using Xtensive.Sql.Info;
using Xtensive.Sql.Model;
using Xtensive.Sql.Ddl;
using Xtensive.Sql.Dml;

namespace Xtensive.Sql.Drivers.SqlServer.v09
{
  internal class Translator : SqlTranslator
  {
    public override string DateTimeFormatString { get { return @"'cast ('\'yyyy\-MM\-ddTHH\:mm\:ss\.fff\'' as datetime)'"; } }
    public override string TimeSpanFormatString { get { return string.Empty; } }
    public override string FloatFormatString { get { return "'cast('" + base.FloatFormatString  + "'e0 as real')"; } }
    public override string DoubleFormatString { get { return "'cast('" + base.DoubleFormatString + "'e0 as float')"; } }

    public override void Initialize()
    {
      base.Initialize();
      FloatNumberFormat.NumberDecimalSeparator = ".";
      DoubleNumberFormat.NumberDecimalSeparator = ".";
    }

    public override string Translate(SqlCompilerContext context, SqlFunctionCall node, FunctionCallSection section, int position)
    {
      switch (section) {
      case FunctionCallSection.ArgumentEntry:
        return string.Empty;
      case FunctionCallSection.ArgumentDelimiter:
        return ArgumentDelimiter;
      default:
        return base.Translate(context, node, section, position);
      }
    }

    public override string Translate(SqlFunctionType functionType)
    {
      switch (functionType) {
      case SqlFunctionType.IntervalAbs:
        return "ABS";
      case SqlFunctionType.IntervalNegate:
        return "-";
      case SqlFunctionType.CurrentDate:
        return "GETDATE";
      case SqlFunctionType.CharLength:
        return "LEN";
      case SqlFunctionType.BinaryLength:
        return "DATALENGTH";
      case SqlFunctionType.Position:
        return "CHARINDEX";
      case SqlFunctionType.Atan2:
        return "ATN2";
      case SqlFunctionType.LastAutoGeneratedId:
        return "SCOPE_IDENTITY";
      }
      return base.Translate(functionType);
    }

    public override string Translate(SqlNodeType type)
    {
      switch (type) {
      case SqlNodeType.Count:
        return "COUNT_BIG";
      case SqlNodeType.Concat:
        return "+";
      case SqlNodeType.Overlaps:
        throw new NotSupportedException(string.Format(Strings.ExOperationXIsNotSupported, type));
      }
      return base.Translate(type);
    }

    public override string Translate(SqlCompilerContext context, TableColumn column, TableColumnSection section)
    {
      switch (section) {
      case TableColumnSection.Type:
        return column.Domain==null
          ? Translate(column.DataType)
          : QuoteIdentifier(column.Domain.Schema.DbName, column.Domain.DbName);
      case TableColumnSection.GenerationExpressionEntry:
        return "AS (";
      case TableColumnSection.GeneratedEntry:
      case TableColumnSection.GeneratedExit:
      case TableColumnSection.SetIdentityInfoElement:
      case TableColumnSection.Exit:
        return string.Empty;
      default:
        return base.Translate(context, column, section);
      }
    }

    public override string Translate(SqlCompilerContext context, SqlAlterTable node, AlterTableSection section)
    {
      switch (section) {
      case AlterTableSection.AddColumn:
        return "ADD";
      case AlterTableSection.DropBehavior:
        return string.Empty;
      default:
        return base.Translate(context, node, section);
      }
    }

    public override string Translate(SqlCompilerContext context, SequenceDescriptor descriptor, SequenceDescriptorSection section)
    {
      return TranslateIdentityDescriptor(context, descriptor, section);
    }

    protected string TranslateIdentityDescriptor(SqlCompilerContext context, SequenceDescriptor descriptor, SequenceDescriptorSection section)
    {
      switch (section) {
        case SequenceDescriptorSection.StartValue:
        case SequenceDescriptorSection.RestartValue:
          if (descriptor.StartValue.HasValue)
            return "IDENTITY (" + descriptor.StartValue.Value + RowItemDelimiter;
          return String.Empty;
        case SequenceDescriptorSection.Increment:
          if (descriptor.Increment.HasValue)
            return descriptor.Increment.Value + ")";
          return String.Empty;
        default:
          return String.Empty;
      }
    }

    public override string Translate(SqlCompilerContext context, Constraint constraint, ConstraintSection section)
    {
      switch (section) {
        case ConstraintSection.Unique:
          if (Driver.ServerInfo.UniqueConstraint.Features.Supports(UniqueConstraintFeatures.Clustered))
            return ((UniqueConstraint) constraint).IsClustered ? "UNIQUE CLUSTERED (" : "UNIQUE NONCLUSTERED (";
          return "UNIQUE (";
        case ConstraintSection.PrimaryKey:
          if (Driver.ServerInfo.PrimaryKey.Features.Supports(PrimaryKeyConstraintFeatures.Clustered))
            return ((PrimaryKey) constraint).IsClustered ? "PRIMARY KEY CLUSTERED (" : "PRIMARY KEY NONCLUSTERED (";
          return "PRIMARY KEY (";
        case ConstraintSection.Exit:
          ForeignKey fk = constraint as ForeignKey;
          if (fk!=null) {
            StringBuilder builder = new StringBuilder();
            builder.Append(")");
            if (fk.OnUpdate!=ReferentialAction.Restrict &&
              fk.OnUpdate!=ReferentialAction.NoAction)
              builder.Append(" ON UPDATE " + Translate(fk.OnUpdate));
            if (fk.OnDelete!=ReferentialAction.Restrict &&
              fk.OnDelete!=ReferentialAction.NoAction)
              builder.Append(" ON DELETE " + Translate(fk.OnDelete));
            return builder.ToString();
          }
          return ")";
        default:
          return base.Translate(context, constraint, section);
      }
    }

    public override string Translate(SqlCompilerContext context, SqlCreateTable node, CreateTableSection section)
    {
      switch (section) {
      case CreateTableSection.Entry:
        var builder = new StringBuilder();
        builder.Append("CREATE ");
        var temporaryTable = node.Table as TemporaryTable;
        if (temporaryTable!=null) {
          if (temporaryTable.IsGlobal)
            temporaryTable.DbName = "##" + temporaryTable.Name;
          else
            temporaryTable.DbName = "#" + temporaryTable.Name;
        }
        builder.Append("TABLE " + Translate(context, node.Table));
        return builder.ToString();
      case CreateTableSection.Exit:
        string result = string.IsNullOrEmpty(node.Table.Filegroup)
          ? string.Empty
          : " ON " + QuoteIdentifier(node.Table.Filegroup);
        return result;
      }
      return base.Translate(context, node, section);
    }

    public override string Translate(SqlCompilerContext context, SqlCreateView node, NodeSection section)
    {
      switch (section)
      {
        case NodeSection.Exit:
          if (node.View.CheckOptions == CheckOptions.Cascaded)
            return "WITH CHECK OPTION";
          else
            return string.Empty;
        default:
          return base.Translate(context, node, section);
      }
    }

    public override string Translate(SqlCompilerContext context, SqlCreateDomain node, CreateDomainSection section)
    {
      switch (section) {
      case CreateDomainSection.Entry:
        return string.Format("CREATE TYPE {0} FROM {1}", Translate(context, node.Domain), Translate(node.Domain.DataType));
      default:
        return string.Empty;
      }
    }

    public override string Translate(SqlCompilerContext context, SqlDropDomain node)
    {
      return string.Format("DROP TYPE {0}", Translate(context, node.Domain));
    }

    public override string Translate(SqlCompilerContext context, SqlAlterDomain node, AlterDomainSection section)
    {
      throw SqlHelper.NotSupported("ALTER DOMAIN"); // NOTE: Do not localize, it's an SQL keyword
    }

    public override string Translate(SqlCompilerContext context, SqlDeclareCursor node, DeclareCursorSection section)
    {
      if (section==DeclareCursorSection.Holdability || section==DeclareCursorSection.Returnability)
        return string.Empty;
      return base.Translate(context, node, section);
    }

    public override string Translate(SqlCompilerContext context, SqlJoinExpression node, JoinSection section)
    {
      switch (section) {
        case JoinSection.Specification:
          if (node.Expression==null)
            switch (node.JoinType) {
            case SqlJoinType.InnerJoin:
            case SqlJoinType.LeftOuterJoin:
            case SqlJoinType.RightOuterJoin:
            case SqlJoinType.FullOuterJoin:
              throw new NotSupportedException();
            case SqlJoinType.CrossApply:
              return "CROSS APPLY";
            case SqlJoinType.LeftOuterApply:
              return "OUTER APPLY";
             }
          var joinHint = TryFindJoinHint(context, node);
          return Translate(node.JoinType)
            + (joinHint != null ? " " + Translate(joinHint.Method) : string.Empty) + " JOIN";
      }
      return base.Translate(context, node, section);
    }

    public override string Translate(SqlCompilerContext context, SqlQueryExpression node, QueryExpressionSection section)
    {
      if (node.All && section==QueryExpressionSection.All && (node.NodeType==SqlNodeType.Except || node.NodeType==SqlNodeType.Intersect))
        return string.Empty;
      return base.Translate(context, node, section);
    }

    private static SqlJoinHint TryFindJoinHint(SqlCompilerContext context, SqlJoinExpression node)
    {
      SqlQueryStatement statement = null;
      for (int i = 0, count = context.GetTraversalPath().Length; i < count; i++) {
        if (context.GetTraversalPath()[i] is SqlQueryStatement)
          statement = context.GetTraversalPath()[i] as SqlQueryStatement;
      }
      if (statement==null || statement.Hints.Count==0)
        return null;
      var candidate = statement.Hints
        .OfType<SqlJoinHint>()
        .FirstOrDefault(hint => hint.Table==node.Right);
      return candidate;
    }

    public override string Translate(SqlJoinMethod method)
    {
      switch (method) {
      case SqlJoinMethod.Hash:
        return "HASH";
      case SqlJoinMethod.Merge:
        return "MERGE";
      case SqlJoinMethod.Loop:
        return "LOOP";
      case SqlJoinMethod.Remote:
        return "REMOTE";
      default:
        return string.Empty;
      }
    }

    public override string Translate(SqlCompilerContext context, SqlSelect node, SelectSection section)
    {
      switch (section) {
      case SelectSection.Limit:
        return "TOP";
      case SelectSection.Offset:
        throw new NotSupportedException();
      case SelectSection.Exit:
        if (node.Hints.Count==0)
          return string.Empty;
        var hints = new List<string>(node.Hints.Count);
        foreach (var hint in node.Hints) {
          if (hint is SqlForceJoinOrderHint)
            hints.Add("FORCE ORDER");
          else if (hint is SqlFastFirstRowsHint)
            hints.Add("FAST " + (hint as SqlFastFirstRowsHint).Amount);
          else if (hint is SqlNativeHint)
            hints.Add((hint as SqlNativeHint).HintText);
        }
        return hints.Count > 0 ? "OPTION (" + string.Join(", ", hints.ToArray()) + ")" : string.Empty;
      }

      return base.Translate(context, node, section);
    }

    public override string Translate(SqlCompilerContext context, SqlUpdate node, UpdateSection section)
    {
      switch (section) {
        case UpdateSection.Limit:
          return "TOP";
      }
      return base.Translate(context, node, section);
    }

    public override string Translate(SqlCompilerContext context, SqlDelete node, DeleteSection section)
    {
      switch (section) {
        case DeleteSection.Entry:
          return "DELETE";
        case DeleteSection.Limit:
          return "TOP";
      }
      return base.Translate(context, node, section);
    }

    public override string Translate(SqlCompilerContext context, SqlRenameTable node)
    {
      return TranslateExecSpRename(context, node.Table, Translate(context, node.Table), node.NewName, null);
    }

    public override string Translate(SqlCompilerContext context, SqlCreateIndex node, CreateIndexSection section)
    {
      var baseSectionTranslation = base.Translate(context, node, section);
      if (section!=CreateIndexSection.Exit)
        return baseSectionTranslation;
      var index = node.Index;
      var ftIndex = index as FullTextIndex;
      if (ftIndex==null)
        return baseSectionTranslation;
      if (ftIndex.FullTextCatalog!=null)
        baseSectionTranslation = baseSectionTranslation + " ON " + QuoteIdentifier(ftIndex.FullTextCatalog);
      return baseSectionTranslation + " WITH CHANGE_TRACKING " + TranslateChangeTrackingMode(ftIndex.ChangeTrackingMode);
    }

    public virtual string Translate(SqlCompilerContext context, SqlRenameColumn action)
    {
      var table = action.Column.Table;
      var schema = table.Schema;
      var columnName = QuoteIdentifier(schema.Catalog.DbName, schema.DbName, table.DbName, action.Column.DbName);
      return TranslateExecSpRename(context, table, columnName, action.NewName, "COLUMN");
    }

    public virtual string Translate(SqlCompilerContext context, SqlAlterTable node, DefaultConstraint constraint)
    {
      return TranslateExecDropDefaultConstraint(context, node, constraint);
    }

    protected string TranslateExecSpRename(SqlCompilerContext context, SchemaNode affectedNode, string objectName, string newName, string type)
    {
      var result = new StringBuilder();
      result.Append("EXEC ");
      if (context.HasOptions(SqlCompilerNamingOptions.DatabaseQualifiedObjects))
        result.AppendFormat("{0}..", QuoteIdentifier(affectedNode.Schema.Catalog.DbName));
      result.AppendFormat("sp_rename '{0}', '{1}'", objectName, newName);
      if (type!=null)
        result.AppendFormat(", '{0}'", type);
      return result.ToString();
    }

    protected string TranslateExecDropDefaultConstraint(SqlCompilerContext context, SqlAlterTable node,  DefaultConstraint defaultConstraint)
    {
      var resultBuilder = new StringBuilder();
      var column = defaultConstraint.Column;
      var table = defaultConstraint.Table;
      var schema = defaultConstraint.Column.DataTable.Schema;
      var gettingNameOfDefaultConstraintScript = GetCurentNameOfDefaultConstraintScript();

      var sqlVariableName = RemoveFromStringInvalidCharacters(string.Format("var_{0}_{1}_{2}", schema.DbName,
        table.DbName,
        column.DbName));

      resultBuilder.Append(string.Format(gettingNameOfDefaultConstraintScript, 
        sqlVariableName,
        QuoteIdentifier(schema.Catalog.DbName),
        schema.DbName,
        table.DbName,
        column.DbName));
      resultBuilder.Append(" ");
      resultBuilder.Append("Exec(N'");
      resultBuilder.Append(Translate(context, node, AlterTableSection.Entry));
      resultBuilder.Append(Translate(context, node, AlterTableSection.DropConstraint));
      resultBuilder.AppendFormat(" CONSTRAINT [' + @{0} + N']')", sqlVariableName);
      return resultBuilder.ToString();
    }

    protected virtual string GetCurentNameOfDefaultConstraintScript()
    {
      var resultBuilder = new StringBuilder();
      resultBuilder.Append("DECLARE @{0} VARCHAR(256) ");
      resultBuilder.Append(
      @"SELECT
        @{0} = {1}.sys.default_constraints.name
      FROM 
        {1}.sys.all_columns
      INNER JOIN
        {1}.sys.tables
      ON all_columns.object_id = tables.object_id
      INNER JOIN 
        {1}.sys.schemas
      ON tables.schema_id = schemas.schema_id  
      INNER JOIN
        {1}.sys.default_constraints
      ON all_columns.default_object_id = default_constraints.object_id

      WHERE 
        schemas.name = '{2}'
        AND tables.name = '{3}'
        AND all_columns.name = '{4}'");
      return resultBuilder.ToString();
    }

    protected string RemoveFromStringInvalidCharacters(string name)
    {
      var normalizedName = name.Aggregate(string.Empty, 
        (current, character) => current.Insert(current.Length, !Char.IsLetterOrDigit(character) 
          ? Convert.ToString('_', CultureInfo.InvariantCulture) 
          : Convert.ToString(character, CultureInfo.InvariantCulture)));
      return normalizedName;
    }

    protected void AddUseStatement(SqlCompilerContext context, Catalog catalog, StringBuilder output)
    {
      if (context.HasOptions(SqlCompilerNamingOptions.DatabaseQualifiedObjects))
        output.AppendFormat("USE [{0}]; ", catalog.DbName);
    }
    
    public override string Translate(SqlCompilerContext context, SqlExtract node, ExtractSection section)
    {
      switch (section) {
      case ExtractSection.Entry:
        return "DATEPART(";
      case ExtractSection.From:
        return ",";
      default:
        return base.Translate(context, node, section);
      }
    }

    public override string Translate(SqlCompilerContext context, SqlTableRef node, TableSection section)
    {
      var reference = base.Translate(context, node, section);
      if (section!=TableSection.AliasDeclaration)
        return reference;
      var select = context.GetTraversalPath()
        .OfType<SqlSelect>()
        .Where(s => s.Lock!=SqlLockType.Empty)
        .FirstOrDefault();
      return select==null ? reference : string.Format("{0} WITH ({1})", reference, Translate(select.Lock));
    }

    public override string Translate(SqlCompilerContext context, SqlTrim node, TrimSection section)
    {
      switch (section) {
      case TrimSection.Entry:
        switch (node.TrimType) {
        case SqlTrimType.Leading:
          return "LTRIM(";
        case SqlTrimType.Trailing:
          return "RTRIM(";
        case SqlTrimType.Both:
          return "LTRIM(RTRIM(";
        default:
          throw new ArgumentOutOfRangeException();
        }
      case TrimSection.Exit:
        switch (node.TrimType) {
        case SqlTrimType.Leading:
        case SqlTrimType.Trailing:
          return ")";
        case SqlTrimType.Both:
          return "))";
        default:
          throw new ArgumentOutOfRangeException();
        }
      default:
        throw new ArgumentOutOfRangeException();
      }
    }

    public override string Translate(SqlCompilerContext context, SqlDropSchema node)
    {
      return "DROP SCHEMA " + QuoteIdentifier(node.Schema.DbName);
    }

    public override string Translate(SqlCompilerContext context, SqlDropTable node)
    {
      return "DROP TABLE " + Translate(context, node.Table);
    }

    public override string Translate(SqlCompilerContext context, SqlDropView node)
    {
      return "DROP VIEW " + Translate(context, node.View);
    }

    public override string Translate(SqlTrimType type)
    {
      return string.Empty;
    }

    public override string Translate(SqlCompilerContext context, object literalValue)
    {
      var literalType = literalValue.GetType();
      if (literalType == typeof(string) || literalType == typeof(char))
        return "N" + QuoteString(literalValue.ToString());
      if (literalType==typeof (TimeSpan))
        return Convert.ToString((long) ((TimeSpan) literalValue).Ticks*100);
      if (literalType==typeof (Boolean))
        return ((bool) literalValue) ? "cast(1 as bit)" : "cast(0 as bit)";
      if (literalType==typeof(DateTime)) {
        var dateTime = (DateTime) literalValue;
        var dateTimeRange = (ValueRange<DateTime>) Driver.ServerInfo.DataTypes.DateTime.ValueRange;
        var newValue = ValueRangeValidator.Correct(dateTime, dateTimeRange);
        return newValue.ToString(DateTimeFormatString);
      }
      if (literalType==typeof(byte[])) {
        var array = (byte[]) literalValue;
        var builder = new StringBuilder(2 * (array.Length + 1));
        builder.Append("0x");
        builder.AppendHexArray(array);
        return builder.ToString();
      }
      if (literalType==typeof(Guid))
        return QuoteString(literalValue.ToString());
      if (literalType==typeof (Int64))
        return String.Format("CAST({0} as BIGINT)", literalValue);
      return base.Translate(context, literalValue);
    }
    
    public override string Translate(SqlLockType lockType)
    {
      var items = new List<string>();
      items.Add("ROWLOCK");
      if (lockType.Supports(SqlLockType.Update))
        items.Add("UPDLOCK");
      else if (lockType.Supports(SqlLockType.Exclusive))
        items.Add("XLOCK");
      if (lockType.Supports(SqlLockType.ThrowIfLocked))
        items.Add("NOWAIT");
      else if (lockType.Supports(SqlLockType.SkipLocked))
        items.Add("READPAST");
      return items.ToCommaDelimitedString();
    }

    public override string Translate(Collation collation)
    {
      return collation.DbName;
    }

    protected virtual string TranslateChangeTrackingMode(ChangeTrackingMode mode)
    {
      switch (mode) {
      case ChangeTrackingMode.Auto:
        return "AUTO";
      case ChangeTrackingMode.Manual:
        return "MANUAL";
      case ChangeTrackingMode.Off:
        return "OFF";
      case ChangeTrackingMode.OffWithNoPopulation:
        return "OFF, NO POPULATION";
      default:
        return "AUTO";
      }
    }


    // Constructors

    /// <summary>
    /// Initializes a new instance of the <see cref="Translator"/> class.
    /// </summary>
    /// <param name="driver">The driver.</param>
    protected internal Translator(SqlDriver driver)
      : base(driver)
    {
    }
  }
}