// Copyright (C) 2003-2010 Xtensive LLC.
// All rights reserved.
// For conditions of distribution and use, see license.
// Created by: Alexis Kochetov
// Created:    2009.11.18

using System;
using Xtensive.Arithmetic;
using Xtensive.Comparison;
using Xtensive.Core;
using Xtensive.Tuples;
using Tuple = Xtensive.Tuples.Tuple;
using Xtensive.Orm.Model;
using Xtensive.Orm.Providers;


namespace Xtensive.Orm
{
  /// <summary>
  /// Default <see cref="KeyGenerator"/> implementation.
  /// </summary>
  /// <typeparam name="TKeyType">The type of the key field.</typeparam>
  public class KeyGenerator<TKeyType> : KeyGenerator
  {
    private const string DefaultTemporaryStringKeyPrefix = "@=";
    private static readonly Type fieldType = typeof (TKeyType);

    private string temporaryStringKeyPrefix = DefaultTemporaryStringKeyPrefix;
    private readonly object syncRoot = new object();
    private Tuple tuplePrototype;
    private TKeyType lastTemporary;
    private TKeyType last;
    private Arithmetic<TKeyType> arithmetic;
    private AdvancedComparer<TKeyType> comparer;

    /// <exception cref="NotSupportedException">Already initialized.</exception>
    public string TemporaryStringKeyPrefix {
      get { return temporaryStringKeyPrefix; }
      set {
        if (temporaryStringKeyPrefix!=DefaultTemporaryStringKeyPrefix)
          throw Exceptions.AlreadyInitialized("TemporaryStringKeyPrefix");
        temporaryStringKeyPrefix = value;
      }
    }


    /// <summary>
    /// Gets the sequence increment value for the underlying sequence,
    /// if this key generator requires it.
    /// Otherwise, returns <see langword="null"/>.
    /// </summary>
    /// <returns>Sequence increment value.</returns>
    public override long? SequenceIncrement { 
      get { return null; }
    }

    /// <summary>
    /// Gets the sync root used to serialize key generation.
    /// </summary>
    protected object SyncRoot {
      get { return syncRoot; }
    }

    /// <summary>
    /// Gets the tuple prototype for this key generator.
    /// </summary>
    protected Tuple TuplePrototype {
      get {
        if (tuplePrototype==null)
          tuplePrototype = Tuple.Create(KeyInfo.TupleDescriptor);
        return tuplePrototype;
      }
    }

    /// <summary>
    /// Gets the arithmetic for <typeparamref name="TKeyType"/>, if available.
    /// </summary>
    public Arithmetic<TKeyType> Arithmetic {
      get { return arithmetic; }
    }

    /// <summary>
    /// Gets the advanced comparer for <typeparamref name="TKeyType"/>, if available.
    /// </summary>
    public AdvancedComparer<TKeyType> Comparer {
      get { return comparer; }
    }

    
    /// <exception cref="NotSupportedException">Unsupported key field type.</exception>
    public override bool IsTemporaryKey(Tuple key) 
    {
      var value = key.GetValue<TKeyType>(0);
      if (arithmetic!=null) {
        if (arithmetic.IsSigned)
          return comparer.Compare(arithmetic.Zero, value) > 0;
        else {
          var maxSigned = arithmetic.Divide(arithmetic.MaxValue, 2);
          return comparer.Compare(maxSigned, value) < 0;
        }
      }
      else {
        if (fieldType==typeof(Guid)) {
          return false;
//          var bytes = ((Guid) (object) value).ToByteArray();
//          ulong highULong = BitConverter.ToUInt64(bytes, 8);
//          return highULong==0;
        }
        if (fieldType==typeof (string))
          return false;
//          return ((string) (object) value).StartsWith(TemporaryStringKeyPrefix);
        throw new NotSupportedException(
          Strings.ExSpecifiedKeyFieldTypeIsNotSupportedByThisTemporaryKeyGenerator);
      }
    }


    
    /// <exception cref="NotImplementedException">Non-temporary keys must be 
    /// generated by descendants.</exception>
    public override Tuple TryGenerateKey(bool temporaryKey)
    {
      return DefaultNext(temporaryKey);
    }

    /// <summary>
    /// Default <see cref="TryGenerateKey"/> method implementation.
    /// </summary>
    /// <param name="temporaryKey">If set to <see langword="true"/>, a temporary key must be created.</param>
    /// <returns>Generated key;
    /// <see langword="null" />, if required key can not be generated.</returns>
    protected Tuple DefaultNext(bool temporaryKey)
    {
      var result = TuplePrototype.CreateNew();
      lock (syncRoot) {
        if (!temporaryKey) {
          last = GetNextValue(last);
          result.SetValue(0, last);
          return result;
        }
        else {
          lastTemporary = GetNextTemporaryValue(lastTemporary);
          result.SetValue(0, lastTemporary);
          return result;
        }
      }
    }

    /// <exception cref="NotSupportedException">Unsupported key field type.</exception>
    private TKeyType GetNextValue(TKeyType currentValue)
    {
      if (arithmetic!=null)
        return arithmetic.Add(currentValue, arithmetic.One);
      else {
        if (fieldType==typeof(Guid))
          return (TKeyType) (object) Guid.NewGuid();
        if (fieldType==typeof(string))
          return (TKeyType) (object) Guid.NewGuid().ToString();
        throw new NotSupportedException(
          Strings.ExSpecifiedKeyFieldTypeIsNotSupportedByThisTemporaryKeyGenerator);
      }
    }

    /// <exception cref="NotSupportedException">Unsupported key field type.</exception>
    private TKeyType GetNextTemporaryValue(TKeyType currentValue)
    {
      if (arithmetic!=null)
        return arithmetic.Subtract(currentValue, arithmetic.One);
      else {
        if (fieldType==typeof(Guid)) {
          return (TKeyType) (object) Guid.NewGuid();
//          var bytes = ((Guid) (object) lastTemporary).ToByteArray();
//          ulong lowULong = BitConverter.ToUInt64(bytes, 0);
//          unchecked { lowULong += 1; }
//          BitConverter.GetBytes(lowULong).Copy(bytes, 0);
//          return (TKeyType) (object) new Guid(bytes);
        }
        if (fieldType==typeof(string)) {
          return (TKeyType) (object) Guid.NewGuid().ToString();
//          string strValue = (string) (object) currentValue;
//          strValue = strValue.TryCutPrefix(TemporaryStringKeyPrefix);
//          long longValue = long.Parse(strValue);
//          longValue--;
//          return (TKeyType) (object) (TemporaryStringKeyPrefix + longValue);
        }
        throw new NotSupportedException(
          Strings.ExSpecifiedKeyFieldTypeIsNotSupportedByThisTemporaryKeyGenerator);
      }
    }


    /// <summary>
    /// Initializer.
    /// </summary>
    /// <param name="handlers">Handler accessor.</param>
    /// <param name="keyInfo">The <see cref="KeyInfo"/> instance that describes generator.</param>
    /// <exception cref="NotSupportedException">Instance is already initialized.</exception>
    protected internal override void Initialize(HandlerAccessor handlers, KeyInfo keyInfo)
    {
      base.Initialize(handlers, keyInfo);
      arithmetic = Arithmetic<TKeyType>.Default;
      if (arithmetic!=null)
        arithmetic = arithmetic.ApplyRules(
          new ArithmeticRules(NullBehavior.ThreatNullAsNull, OverflowBehavior.AllowOverflow));
      comparer = AdvancedComparer<TKeyType>.Default;
      if (arithmetic!=null)
        lastTemporary = arithmetic.Zero;
      else {
        if (fieldType==typeof (Guid))
          lastTemporary = (TKeyType) (object) Guid.Empty;
        else if (fieldType==typeof (string))
          lastTemporary = (TKeyType) (object) (TemporaryStringKeyPrefix + "0");
      }
      last = lastTemporary;
    }


    /// <summary>
    /// Called on background thread to fully prepare the key generator.
    /// Since this method is called optionally, it can't do any essential
    /// job.
    /// But it can e.g. invoke some properties that needs delayed
    /// evaluation, and so on.
    /// </summary>
    protected internal override void Prepare()
    {
      base.Prepare();
      var ignored = TuplePrototype;
    }
  }
}