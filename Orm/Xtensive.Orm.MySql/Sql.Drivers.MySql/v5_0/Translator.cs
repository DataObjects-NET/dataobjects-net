// Copyright (C) 2011-2021 Xtensive LLC.
// This code is distributed under MIT license terms.
// See the License.txt file in the project root for more information.
// Created by: Malisa Ncube
// Created:    2011.02.25

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using Xtensive.Core;
using Xtensive.Sql.Compiler;
using Xtensive.Sql.Ddl;
using Xtensive.Sql.Dml;
using Xtensive.Sql.Drivers.MySql.Resources;
using Xtensive.Sql.Model;
using Index = Xtensive.Sql.Model.Index;

namespace Xtensive.Sql.Drivers.MySql.v5_0
{
  internal class Translator : SqlTranslator
  {
    public override string DateTimeFormatString
    {
      get { return @"\'yyyy\-MM\-dd HH\:mm\:ss\.ffffff\'"; }
    }

    public override string TimeSpanFormatString
    {
      get { return string.Empty; }
    }

    public override string DdlStatementDelimiter
    {
      get { return ";"; }
    }

    public override string BatchItemDelimiter
    {
      get { return ";\r\n"; }
    }

    public override void Initialize()
    {
      base.Initialize();

      FloatNumberFormat.NumberDecimalSeparator = ".";
      FloatNumberFormat.NumberGroupSeparator = "";

      DoubleNumberFormat.NumberDecimalSeparator = ".";
      DoubleNumberFormat.NumberGroupSeparator = "";
    }

    public override SqlHelper.EscapeSetup EscapeSetup => SqlHelper.EscapeSetup.WithBackTick;

    /// <inheritdoc/>
    [DebuggerStepThrough]
    public override string QuoteString(string str)
    {
      return "'" + str.Replace("'", "''").Replace(@"\", @"\\").Replace("\0", string.Empty) + "'";
    }

    protected override void TranslateStringChar(IOutput output, char ch)
    {
      switch (ch) {
        case '\\':
          output.AppendLiteral("\\\\");
          break;
        default:
          base.TranslateStringChar(output, ch);
          break;
      }
    }

    public override void Translate(SqlCompilerContext context, SqlSelect node, SelectSection section)
    {
      switch (section) {
        case SelectSection.HintsEntry:
          break;
        case SelectSection.HintsExit:
          if (node.Hints.Count == 0)
            break;
          var hints = new List<string>(node.Hints.Count);
          foreach (SqlHint hint in node.Hints) {
            if (hint is SqlNativeHint sqlNativeHint)
              hints.Add(QuoteIdentifier(sqlNativeHint.HintText));
          }
          if (hints.Count > 0) {
            context.Output.Append("USE INDEX (")
              .Append(string.Join(", ", hints))
              .Append(")");
          }
          break;
        default:
          base.Translate(context, node, section);
          break;
      }
    }

    /// <inheritdoc/>
    public override string Translate(SqlFunctionType type)
    {
      switch (type) {
        case SqlFunctionType.LastAutoGeneratedId:
          return "LAST_INSERT_ID()";
        case SqlFunctionType.SystemUser:
          return "SYSTEM_USER()";
        case SqlFunctionType.User:
        case SqlFunctionType.CurrentUser:
          return "CURRENT_USER()";
        case SqlFunctionType.SessionUser:
          return "SESSION_USER()";
        case SqlFunctionType.NullIf:
          return "IFNULL";
        case SqlFunctionType.Coalesce:
          return "COALESCE";
        case SqlFunctionType.BinaryLength:
          return "LENGTH";

          //datetime/timespan

        case SqlFunctionType.DateTimeTruncate:
          return "DATE";
        case SqlFunctionType.CurrentDate:
          return "CURDATE()";
        case SqlFunctionType.CurrentTimeStamp:
          return "NOW()";
        case SqlFunctionType.IntervalNegate:
          return "-";
        case SqlFunctionType.DateTimeAddYears:
        case SqlFunctionType.DateTimeAddMonths:
        case SqlFunctionType.DateTimeConstruct:
        case SqlFunctionType.IntervalToMilliseconds:
          return string.Empty;
          //string

        case SqlFunctionType.CharLength:
          return "CHAR_LENGTH";
        case SqlFunctionType.Lower:
          return "LCASE";
        case SqlFunctionType.Position:
          return "LOCATE";
        case SqlFunctionType.Substring:
          return "SUBSTRING";
        case SqlFunctionType.Upper:
          return "UCASE";
        case SqlFunctionType.Concat:
          return "CONCAT()";
          //math

        case SqlFunctionType.Abs:
          return "ABS";
        case SqlFunctionType.Acos:
          return "ACOS";
        case SqlFunctionType.Asin:
          return "ASIN";
        case SqlFunctionType.Atan:
          return "ATAN";
        case SqlFunctionType.Atan2:
          return "ATAN2";
        case SqlFunctionType.Ceiling:
          return "CEIL";
        case SqlFunctionType.Cos:
          return "COS";
        case SqlFunctionType.Cot:
          return "COT";
        case SqlFunctionType.Degrees:
          return "DEGREES";
        case SqlFunctionType.Exp:
          return "EXP";
        case SqlFunctionType.Floor:
          return "FLOOR";
        case SqlFunctionType.Log:
          return "LN";
        case SqlFunctionType.Log10:
          return "LOG";
        case SqlFunctionType.Pi:
          return "PI";
        case SqlFunctionType.Power:
          return "POWER";
        case SqlFunctionType.Radians:
          return "RADIANS";
        case SqlFunctionType.Rand:
          return "RAND";
        case SqlFunctionType.Round:
          return "ROUND";
        case SqlFunctionType.Truncate:
          return "TRUNCATE";
        case SqlFunctionType.Sign:
          return "SIGN";
        case SqlFunctionType.Sqrt:
          return "SQRT";
        case SqlFunctionType.Tan:
          return "TAN";
        default:
          return base.Translate(type);
      }
    }

    /// <inheritdoc/>
    public override void Translate(SqlCompilerContext context, SequenceDescriptor descriptor,
      SequenceDescriptorSection section)
    {
      //throw new NotSupportedException(Strings.ExDoesNotSupportSequences);
    }

    /// <inheritdoc/>
    public override string Translate(ReferentialAction action)
    {
      switch (action) {
        case ReferentialAction.Cascade:
          return "CASCADE";
        case ReferentialAction.NoAction:
          return "NO ACTION";
        case ReferentialAction.Restrict:
          return "RESTRICT";
        case ReferentialAction.SetDefault:
          return "SET DEFAULT";
        case ReferentialAction.SetNull:
          return "SET NULL";
      }
      return string.Empty;
    }

    /// <inheritdoc/>
    public override string Translate(SqlNodeType type)
    {
      switch (type) {
        case SqlNodeType.Concat:
          return ",";
        case SqlNodeType.DateTimePlusInterval:
          return "+";
        case SqlNodeType.DateTimeMinusInterval:
        case SqlNodeType.DateTimeMinusDateTime:
          return "-";
        case SqlNodeType.Equals:
          return "=";
        case SqlNodeType.NotEquals:
          return "<>";
        case SqlNodeType.Modulo:
          return "MOD";
        case SqlNodeType.Intersect:
        case SqlNodeType.Except:
          throw SqlHelper.NotSupported(type.ToString());
        case SqlNodeType.BitAnd:
          return "&";
        case SqlNodeType.BitOr:
          return "|";
        case SqlNodeType.BitXor:
          return "^";
        case SqlNodeType.Overlaps:
          throw SqlHelper.NotSupported(type.ToString());
        default:
          return base.Translate(type);
      }
    }

    //TODO: Concat Fix and not introduce problems with numerics. a+b. Translate 'a' + 'b' => concat('a', 'b')
    //public override string Translate(SqlCompilerContext context, SqlBinary node, NodeSection section)
    //{
    //    switch (section)
    //    {
    //        case NodeSection.Entry:
    //            return (node.NodeType == SqlNodeType.RawConcat) ? string.Empty : "CONCAT(";
    //        case NodeSection.Exit:
    //            return (node.NodeType == SqlNodeType.RawConcat) ? string.Empty : ClosingParenthesis;
    //    }
    //    return string.Empty;
    //}

    public override void Translate(SqlCompilerContext context, SqlConcat node, NodeSection section)
    {
      switch (section) {
        case NodeSection.Entry:
          context.Output.Append("CONCAT(");
          break;
        case NodeSection.Exit:
          context.Output.Append(")");
          break;
      }
    }

    public override void Translate(SqlCompilerContext context, SchemaNode node)
    {
      TranslateIdentifier(context.Output, node.Name);
    }

    public override void Translate(SqlCompilerContext context, SqlCreateTable node, CreateTableSection section)
    {
      var output = context.Output;
      switch (section) {
        case CreateTableSection.Entry:
          output.Append("CREATE ");
          var temporaryTable = node.Table as TemporaryTable;
          if (temporaryTable != null) {
            output.Append("TEMPORARY TABLE ");
            Translate(context, temporaryTable);
          }
          else {
            output.Append("TABLE ");
            Translate(context, node.Table);
          }
          return;
        case CreateTableSection.Exit:
          return;
      }
      base.Translate(context, node, section);
    }


    public override void Translate(SqlCompilerContext context, TableColumn column, TableColumnSection section)
    {
      switch (section) {
        case TableColumnSection.Exit:
          break;
        case TableColumnSection.GeneratedExit:
          context.Output.Append("AUTO_INCREMENT"); //Workaround based on fake sequence.
          break;
        default:
          base.Translate(context, column, section);
          break;
      }
    }

    public override void Translate(SqlCompilerContext context, SqlCreateIndex node, CreateIndexSection section)
    {
      Index index = node.Index;
      switch (section) {
        case CreateIndexSection.Entry:
          context.Output.Append(
            string.Format("CREATE {0}INDEX {1} USING BTREE ON "
              , index.IsUnique ? "UNIQUE " : (index.IsFullText ? "FULLTEXT " : String.Empty)
              , QuoteIdentifier(index.Name)));
          Translate(context, index.DataTable);
          context.Output.Append(" ");
          break;
        case CreateIndexSection.Exit:
          break;
        default:
          base.Translate(context, node, section);
          break;
      }
    }

    public override void Translate(SqlCompilerContext context, SqlDropIndex node)
    {
      context.Output.Append($"DROP INDEX {QuoteIdentifier(node.Index.Name)} ON {QuoteIdentifier(node.Index.DataTable.Name)}");
    }

    public override void Translate(SqlCompilerContext context, Constraint constraint, ConstraintSection section)
    {
      switch (section) {
        case ConstraintSection.Entry:
          if (constraint is PrimaryKey)
            return;
          base.Translate(context, constraint, section);
          break;
        case ConstraintSection.Exit:
          context.Output.Append(")");
          if (constraint is ForeignKey fk) {
            if (fk.OnUpdate!=ReferentialAction.NoAction)
              context.Output.Append(" ON UPDATE ").Append(Translate(fk.OnUpdate));
            if (fk.OnDelete!=ReferentialAction.NoAction)
              context.Output.Append(" ON DELETE ").Append(Translate(fk.OnDelete));
          }
          break;
        default:
          base.Translate(context, constraint, section);
          break;
      }
    }

    public override void Translate(SqlCompilerContext context, SqlAlterTable node, AlterTableSection section)
    {
      switch (section) {
        case AlterTableSection.DropBehavior:
          var cascadableAction = node.Action as SqlCascadableAction;
          if (cascadableAction==null || !cascadableAction.Cascade)
            return;
          if (cascadableAction is SqlDropConstraint)
            return;
          context.Output.Append(cascadableAction.Cascade ? "CASCADE" : "RESTRICT");
          break;
        default:
          base.Translate(context, node, section);
          break;
      }
    }

    public override void Translate(SqlCompilerContext context, SqlInsert node, InsertSection section)
    {
      if (section == InsertSection.DefaultValues) {
        context.Output.Append("() VALUES ()");
      }
      else {
        base.Translate(context, node, section);
      }
    }

    public override void Translate(SqlCompilerContext context, SqlBreak node)
    {
      //throw new NotSupportedException(Strings.ExCursorsOnlyForProcsAndFuncs);
    }

    public override string Translate(SqlValueType type)
    {
      // we need to explicitly specify maximum interval precision
      if (type.Type==SqlType.Interval)
        return "decimal(18, 18)";
      return base.Translate(type);
    }

    /// <inheritdoc/>
    public override void Translate(SqlCompilerContext context, object literalValue)
    {
      var output = context.Output;
      switch (literalValue) {
        case bool v:
          output.Append(v ? '1' : '0');
          break;
        case UInt64 v:
          TranslateString(output, v.ToString());
          break;
        case byte[] values:
          var builder = output.StringBuilder;
          builder.EnsureCapacity(builder.Length + 2 * (values.Length + 1));
          builder.Append("x'");
          builder.AppendHexArray(values);
          builder.Append("'");
          break;
        case Guid guid:
          TranslateString(output, SqlHelper.GuidToString(guid));
          break;
        case TimeSpan timeSpan:
          output.Append(timeSpan.Ticks * 100);
          break;
        default:
          base.Translate(context, literalValue);
          break;
      }
    }

    /// <inheritdoc/>
    public override void Translate(SqlCompilerContext context, SqlExtract node, ExtractSection section)
    {
      bool isSecond = node.DateTimePart == SqlDateTimePart.Second || node.IntervalPart == SqlIntervalPart.Second;
      bool isMillisecond = node.DateTimePart == SqlDateTimePart.Millisecond ||
        node.IntervalPart == SqlIntervalPart.Millisecond;
      if (!(isSecond || isMillisecond)) {
        base.Translate(context, node, section);
        return;
      }
      switch (section) {
        case ExtractSection.Entry:
          context.Output.Append("(extract(");
          break;
        case ExtractSection.Exit:
          context.Output.Append(isMillisecond ? ") % 1000)" : "))");
          break;
        default:
          base.Translate(context, node, section);
          break;
      }
    }

    /// <inheritdoc/>
    public override void Translate(SqlCompilerContext context, SqlFunctionCall node,
      FunctionCallSection section, int position)
    {
      switch (section) {
        case FunctionCallSection.Entry:
          switch (node.FunctionType) {
            case SqlFunctionType.LastAutoGeneratedId:
            case SqlFunctionType.CurrentUser:
            case SqlFunctionType.SessionUser:
            case SqlFunctionType.SystemUser:
            case SqlFunctionType.User:
            case SqlFunctionType.CurrentDate:
            case SqlFunctionType.CurrentTimeStamp:
              context.Output.Append(Translate(node.FunctionType));
              return;
          }
          break;
        case FunctionCallSection.ArgumentEntry:
          return;
        case FunctionCallSection.ArgumentDelimiter:
          context.Output.Append(ArgumentDelimiter);
          return;
      }
      base.Translate(context, node, section, position);
    }

    /// <inheritdoc/>
    public override void Translate(SqlCompilerContext context, SqlNextValue node, NodeSection section)
    {
      throw new NotSupportedException(Strings.ExDoesNotSupportSequences);
    }

    /// <inheritdoc/>
    public override void Translate(SqlCompilerContext context, SqlCast node, NodeSection section)
    {
      var output = context.Output;
      var sqlType = node.Type.Type;

      if (sqlType == SqlType.Binary ||
        sqlType == SqlType.Char ||
        sqlType == SqlType.Interval ||
        sqlType == SqlType.DateTime) {
        switch (section) {
          case NodeSection.Entry:
            output.Append("CAST(");
            break;
          case NodeSection.Exit:
            output.Append("AS ").Append(Translate(node.Type)).Append(")");
            break;
          default:
            throw new ArgumentOutOfRangeException("section");
        }
      }
      else if (sqlType == SqlType.Int16 || sqlType == SqlType.Int32) {
        switch (section) {
          case NodeSection.Entry:
            output.Append("CAST(");
            break;
          case NodeSection.Exit:
            output.Append("AS SIGNED ").Append(Translate(node.Type)).Append(")");
            break;
          default:
            throw new ArgumentOutOfRangeException("section");
        }
      }
      else if (sqlType == SqlType.Decimal) {
        switch (section) {
          case NodeSection.Entry:
            output.Append("CAST(");
            break;
          case NodeSection.Exit:
            output.Append("AS ").Append(Translate(node.Type)).Append(")");
            break;
          default:
            throw new ArgumentOutOfRangeException("section");
        }
      }
      else if (sqlType == SqlType.Decimal ||
        sqlType == SqlType.Double ||
        sqlType == SqlType.Float) {
        switch (section) {
          case NodeSection.Entry:
          case NodeSection.Exit:
            break;
          default:
            throw new ArgumentOutOfRangeException("section");
        }
      }
    }

    /// <inheritdoc/>
    public override string Translate(SqlDateTimePart part)
    {
      switch (part) {
        case SqlDateTimePart.Millisecond:
          return "MICROSECOND";
        case SqlDateTimePart.Day:
          return "DAY";
        case SqlDateTimePart.Year:
          return "YEAR";
        case SqlDateTimePart.Month:
          return "MONTH";
        case SqlDateTimePart.Hour:
          return "HOUR";
        case SqlDateTimePart.Minute:
          return "MINUTE";
      }

      return base.Translate(part);
    }

    /// <inheritdoc/>
    public override string Translate(SqlLockType lockType)
    {
      if (lockType.Supports(SqlLockType.Shared))
        return "LOCK IN SHARE MODE";
      if (lockType.Supports(SqlLockType.SkipLocked) || lockType.Supports(SqlLockType.ThrowIfLocked))
        return base.Translate(lockType);
      return "FOR UPDATE";
    }

    //----------------------- Other Vendor Type MySQL Type
    //BOOL TINYINT
    //BOOLEAN TINYINT
    //CHARACTER VARYING(M) VARCHAR(M)
    //FIXED DECIMAL
    //FLOAT4 FLOAT
    //FLOAT8 DOUBLE
    //INT1 TINYINT
    //INT2 SMALLINT
    //INT3 MEDIUMINT
    //INT4 INT
    //INT8 BIGINT
    //LONG VARBINARY MEDIUMBLOB
    //LONG VARCHAR MEDIUMTEXT
    //LONG MEDIUMTEXT
    //MIDDLEINT MEDIUMINT
    //NUMERIC DECIMAL
    protected virtual string TranslateClrType(Type type)
    {
      switch (Type.GetTypeCode(type)) {
        case TypeCode.Boolean:
          return "bool";
        case TypeCode.Byte:
        case TypeCode.SByte:
        case TypeCode.Int16:
          return "int2";
        case TypeCode.UInt16:
        case TypeCode.Int32:
          return "int4";
        case TypeCode.UInt32:
        case TypeCode.Int64:
          return "int8";
        case TypeCode.UInt64:
        case TypeCode.Decimal:
          return "numeric";
        case TypeCode.Single:
          return "float4";
        case TypeCode.Double:
          return "float8";
        case TypeCode.Char:
        case TypeCode.String:
          return "text";
        case TypeCode.DateTime:
          return "timestamp";
        default:
          if (type==typeof (TimeSpan))
            return "numeric";
          if (type==typeof (Guid))
            return "text";
          return "text";
      }
    }

    public virtual void Translate(SqlCompilerContext context, SqlRenameColumn action) //TODO: Work on this.
    {
      string schemaName = action.Column.Table.Schema.DbName;
      string tableName = action.Column.Table.DbName;
      string columnName = action.Column.DbName;

      //alter table `actor` change column last_name1 last_name varchar(45)

      var output = context.Output;
      output.Append("ALTER TABLE ");
      TranslateIdentifier(output, tableName);
      output.Append(" CHANGE COLUMN ");
      TranslateIdentifier(output, columnName);
      output.Append(" ");
      TranslateIdentifier(output, action.NewName);
      output.Append(" ")
        .Append(Translate(action.Column.DataType));
    }

    // Constructors

    public Translator(SqlDriver driver)
      : base(driver)
    {
    }
  }
}