// Copyright (C) 2011-2022 Xtensive LLC.
// This code is distributed under MIT license terms.
// See the License.txt file in the project root for more information.
// Created by: Malisa Ncube
// Created:    2011.02.25

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using Xtensive.Core;
using Xtensive.Sql.Compiler;
using Xtensive.Sql.Ddl;
using Xtensive.Sql.Dml;
using Xtensive.Sql.Drivers.MySql.Resources;
using Xtensive.Sql.Model;
using Index = Xtensive.Sql.Model.Index;

namespace Xtensive.Sql.Drivers.MySql.v5_0
{
  internal class Translator : SqlTranslator
  {
    public override string DateTimeFormatString => @"\'yyyy\-MM\-dd HH\:mm\:ss\.ffffff\'";

    public override string TimeSpanFormatString => string.Empty;

    public override string DdlStatementDelimiter => ";";


    public override void Initialize()
    {
      base.Initialize();

      FloatNumberFormat.NumberDecimalSeparator = ".";
      FloatNumberFormat.NumberGroupSeparator = "";

      DoubleNumberFormat.NumberDecimalSeparator = ".";
      DoubleNumberFormat.NumberGroupSeparator = "";
    }

    public override SqlHelper.EscapeSetup EscapeSetup => SqlHelper.EscapeSetup.WithBackTick;

    /// <inheritdoc/>
    [DebuggerStepThrough]
    public override string QuoteString(string str) =>
      "'" + str.Replace("'", "''").Replace(@"\", @"\\").Replace("\0", string.Empty) + "'";

    /// <inheritdoc/>
    protected override void TranslateChar(IOutput output, char ch)
    {
      switch (ch) {
        case '\\':
          _ = output.AppendLiteral("\\\\");
          break;
        default:
          base.TranslateChar(output, ch);
          break;
      }
    }

    /// <inheritdoc/>
    public override void Translate(SqlCompilerContext context, SqlSelect node, SelectSection section)
    {
      switch (section) {
        case SelectSection.HintsEntry:
          break;
        case SelectSection.HintsExit:
          if (node.Hints.Count == 0) {
            break;
          }
          var hints = new List<string>(node.Hints.Count);
          foreach (var hint in node.Hints) {
            if (hint is SqlNativeHint sqlNativeHint) {
              hints.Add(QuoteIdentifier(sqlNativeHint.HintText));
            }
          }
          if (hints.Count > 0) {
            _ = context.Output.Append("USE INDEX (")
              .Append(string.Join(", ", hints))
              .Append(")");
          }
          break;
        default:
          base.Translate(context, node, section);
          break;
      }
    }

    /// <inheritdoc/>
    public override string Translate(SqlFunctionType type)
    {
      return type switch {
        SqlFunctionType.LastAutoGeneratedId => "LAST_INSERT_ID()",
        SqlFunctionType.SystemUser => "SYSTEM_USER()",
        SqlFunctionType.User or SqlFunctionType.CurrentUser => "CURRENT_USER()",
        SqlFunctionType.SessionUser => "SESSION_USER()",
        SqlFunctionType.NullIf => "IFNULL",
        SqlFunctionType.Coalesce => "COALESCE",
        SqlFunctionType.BinaryLength => "LENGTH",
        //datetime/timespan
        SqlFunctionType.DateTimeTruncate => "DATE",
        SqlFunctionType.CurrentDate => "CURDATE()",
        SqlFunctionType.CurrentTimeStamp => "NOW()",
        SqlFunctionType.IntervalNegate => "-",
        SqlFunctionType.DateTimeAddYears or
          SqlFunctionType.DateTimeAddMonths or
          SqlFunctionType.DateTimeConstruct or
          SqlFunctionType.IntervalToMilliseconds => string.Empty,
        //string
        SqlFunctionType.CharLength => "CHAR_LENGTH",
        SqlFunctionType.Lower => "LCASE",
        SqlFunctionType.Position => "LOCATE",
        SqlFunctionType.Substring => "SUBSTRING",
        SqlFunctionType.Upper => "UCASE",
        SqlFunctionType.Concat => "CONCAT()",
        //math
        SqlFunctionType.Abs => "ABS",
        SqlFunctionType.Acos => "ACOS",
        SqlFunctionType.Asin => "ASIN",
        SqlFunctionType.Atan => "ATAN",
        SqlFunctionType.Atan2 => "ATAN2",
        SqlFunctionType.Ceiling => "CEIL",
        SqlFunctionType.Cos => "COS",
        SqlFunctionType.Cot => "COT",
        SqlFunctionType.Degrees => "DEGREES",
        SqlFunctionType.Exp => "EXP",
        SqlFunctionType.Floor => "FLOOR",
        SqlFunctionType.Log => "LN",
        SqlFunctionType.Log10 => "LOG",
        SqlFunctionType.Pi => "PI",
        SqlFunctionType.Power => "POWER",
        SqlFunctionType.Radians => "RADIANS",
        SqlFunctionType.Rand => "RAND",
        SqlFunctionType.Round => "ROUND",
        SqlFunctionType.Truncate => "TRUNCATE",
        SqlFunctionType.Sign => "SIGN",
        SqlFunctionType.Sqrt => "SQRT",
        SqlFunctionType.Tan => "TAN",
        _ => base.Translate(type),
      };
    }

    /// <inheritdoc/>
    public override void Translate(SqlCompilerContext context, SequenceDescriptor descriptor,
      SequenceDescriptorSection section)
    {
      //throw new NotSupportedException(Strings.ExDoesNotSupportSequences);
    }

    /// <inheritdoc/>
    public override string Translate(ReferentialAction action)
    {
      return action switch {
        ReferentialAction.Cascade => "CASCADE",
        ReferentialAction.NoAction => "NO ACTION",
        ReferentialAction.Restrict => "RESTRICT",
        ReferentialAction.SetDefault => "SET DEFAULT",
        ReferentialAction.SetNull => "SET NULL",
        _ => string.Empty,
      };
    }

    /// <inheritdoc/>
    public override string Translate(SqlNodeType type)
    {
      return type switch {
        SqlNodeType.Concat => ",",
        SqlNodeType.DateTimePlusInterval => "+",
        SqlNodeType.DateTimeMinusInterval or SqlNodeType.DateTimeMinusDateTime => "-",
        SqlNodeType.Equals => "=",
        SqlNodeType.NotEquals => "<>",
        SqlNodeType.Modulo => "MOD",
        SqlNodeType.Intersect or SqlNodeType.Except => throw SqlHelper.NotSupported(type.ToString()),
        SqlNodeType.BitAnd => "&",
        SqlNodeType.BitOr => "|",
        SqlNodeType.BitXor => "^",
        SqlNodeType.Overlaps => throw SqlHelper.NotSupported(type.ToString()),
        _ => base.Translate(type),
      };
    }

    //TODO: Concat Fix and not introduce problems with numerics. a+b. Translate 'a' + 'b' => concat('a', 'b')
    //public override string Translate(SqlCompilerContext context, SqlBinary node, NodeSection section)
    //{
    //    switch (section)
    //    {
    //        case NodeSection.Entry:
    //            return (node.NodeType == SqlNodeType.RawConcat) ? string.Empty : "CONCAT(";
    //        case NodeSection.Exit:
    //            return (node.NodeType == SqlNodeType.RawConcat) ? string.Empty : ClosingParenthesis;
    //    }
    //    return string.Empty;
    //}

    /// <inheritdoc/>
    public override void Translate(SqlCompilerContext context, SqlConcat node, NodeSection section)
    {
      switch (section) {
        case NodeSection.Entry:
          _ = context.Output.AppendOpeningPunctuation("CONCAT(");
          break;
        case NodeSection.Exit:
          _ = context.Output.AppendClosingPunctuation(")");
          break;
      }
    }

    /// <inheritdoc/>
    public override void Translate(SqlCompilerContext context, SchemaNode node) => TranslateIdentifier(context.Output, node.Name);

    /// <inheritdoc/>
    public override void Translate(SqlCompilerContext context, SqlCreateTable node, CreateTableSection section)
    {
      var output = context.Output;
      switch (section) {
        case CreateTableSection.Entry:
          _ = output.Append("CREATE ");
          if (node.Table is TemporaryTable temporaryTable) {
            _ = output.Append("TEMPORARY TABLE ");
            Translate(context, temporaryTable);
          }
          else {
            _ = output.Append("TABLE ");
            Translate(context, node.Table);
          }
          return;
        case CreateTableSection.Exit:
          return;
      }
      base.Translate(context, node, section);
    }

    /// <inheritdoc/>
    public override void Translate(SqlCompilerContext context, TableColumn column, TableColumnSection section)
    {
      switch (section) {
        case TableColumnSection.Exit:
          break;
        case TableColumnSection.GeneratedExit:
          _ = context.Output.Append("AUTO_INCREMENT"); //Workaround based on fake sequence.
          break;
        default:
          base.Translate(context, column, section);
          break;
      }
    }

    /// <inheritdoc/>
    public override void Translate(SqlCompilerContext context, SqlCreateIndex node, CreateIndexSection section)
    {
      var index = node.Index;
      switch (section) {
        case CreateIndexSection.Entry:
          var output = context.Output;
          if (index.IsUnique) {
            _ = output.Append("CREATE UNIQUE INDEX ");
          }
          else if (index.IsFullText) {
            _ = output.Append("CREATE FULLTEXT INDEX");
          }
          else {
            _ = output.Append("CREATE INDEX ");
          }
          TranslateIdentifier(output, index.Name);
          _ = output.Append(" USING BTREE ON ");
          Translate(context, index.DataTable);
          _ = output.AppendSpaceIfNecessary();
          break;
        case CreateIndexSection.Exit:
          break;
        default:
          base.Translate(context, node, section);
          break;
      }
    }

    /// <inheritdoc/>
    public override void Translate(SqlCompilerContext context, SqlDropIndex node)
    {
      var output = context.Output;
      _ = output.Append("DROP INDEX ");
      TranslateIdentifier(output, node.Index.Name);
      _ = output.Append(" ON ");
      TranslateIdentifier(output, node.Index.DataTable.Name);
    }

    /// <inheritdoc/>
    public override void Translate(SqlCompilerContext context, Constraint constraint, ConstraintSection section)
    {
      switch (section) {
        case ConstraintSection.Entry:
          if (constraint is PrimaryKey) {
            return;
          }
          base.Translate(context, constraint, section);
          break;
        case ConstraintSection.Exit:
          _ = context.Output.Append(")");
          if (constraint is ForeignKey fk) {
            if (fk.OnUpdate != ReferentialAction.NoAction) {
              _ = context.Output.Append(" ON UPDATE ").Append(Translate(fk.OnUpdate));
            }

            if (fk.OnDelete != ReferentialAction.NoAction) {
              _ = context.Output.Append(" ON DELETE ").Append(Translate(fk.OnDelete));
            }
          }
          break;
        default:
          base.Translate(context, constraint, section);
          break;
      }
    }

    /// <inheritdoc/>
    public override void Translate(SqlCompilerContext context, SqlAlterTable node, AlterTableSection section)
    {
      switch (section) {
        case AlterTableSection.DropBehavior:
          if (node.Action is not SqlCascadableAction cascadableAction || !cascadableAction.Cascade) {
            return;
          }
          if (cascadableAction is SqlDropConstraint) {
            return;
          }
          _ = context.Output.Append(cascadableAction.Cascade ? "CASCADE" : "RESTRICT");
          break;
        default:
          base.Translate(context, node, section);
          break;
      }
    }

    /// <inheritdoc/>
    public override void Translate(SqlCompilerContext context, SqlInsert node, InsertSection section)
    {
      if (section == InsertSection.DefaultValues) {
        _ = context.Output.Append("() VALUES ()");
      }
      else {
        base.Translate(context, node, section);
      }
    }

    /// <inheritdoc/>
    public override void Translate(SqlCompilerContext context, SqlBreak node)
    {
      //throw new NotSupportedException(Strings.ExCursorsOnlyForProcsAndFuncs);
    }

    /// <inheritdoc/>
    public override string Translate(SqlValueType type)
    {
      // we need to explicitly specify maximum interval precision
      return type.Type == SqlType.Interval
        ? "decimal(18, 18)"
        : base.Translate(type);
    }

    /// <inheritdoc/>
    public override void Translate(SqlCompilerContext context, object literalValue)
    {
      var output = context.Output;
      switch (literalValue) {
        case bool v:
          _ = output.Append(v ? '1' : '0');
          break;
        case ulong v:
          TranslateString(output, v.ToString());
          break;
        case byte[] values:
          var builder = output.StringBuilder;
          _ = builder.EnsureCapacity(builder.Length + (2 * (values.Length + 1)));
          _ = builder.Append("x'")
            .AppendHexArray(values)
            .Append('\'');
          break;
        case Guid guid:
          TranslateString(output, SqlHelper.GuidToString(guid));
          break;
        case TimeSpan timeSpan:
          _ = output.Append(timeSpan.Ticks * 100);
          break;
        default:
          base.Translate(context, literalValue);
          break;
      }
    }

    /// <inheritdoc/>
    public override void Translate(SqlCompilerContext context, SqlExtract node, ExtractSection section)
    {
      var isSecond = node.DateTimePart == SqlDateTimePart.Second || node.IntervalPart == SqlIntervalPart.Second;
      var isMillisecond = node.DateTimePart == SqlDateTimePart.Millisecond
        || node.IntervalPart == SqlIntervalPart.Millisecond;
      if (!(isSecond || isMillisecond)) {
        base.Translate(context, node, section);
        return;
      }
      switch (section) {
        case ExtractSection.Entry:
          _ = context.Output.Append("(extract(");
          break;
        case ExtractSection.Exit:
          _ = context.Output.Append(isMillisecond ? ") % 1000)" : "))");
          break;
        default:
          base.Translate(context, node, section);
          break;
      }
    }

    /// <inheritdoc/>
    public override void Translate(SqlCompilerContext context, SqlFunctionCall node,
      FunctionCallSection section, int position)
    {
      switch (section) {
        case FunctionCallSection.Entry:
          switch (node.FunctionType) {
            case SqlFunctionType.LastAutoGeneratedId:
            case SqlFunctionType.CurrentUser:
            case SqlFunctionType.SessionUser:
            case SqlFunctionType.SystemUser:
            case SqlFunctionType.User:
            case SqlFunctionType.CurrentDate:
            case SqlFunctionType.CurrentTimeStamp:
              _ = context.Output.Append(Translate(node.FunctionType));
              return;
          }
          break;
        case FunctionCallSection.ArgumentEntry:
          return;
        case FunctionCallSection.ArgumentDelimiter:
          _ = context.Output.Append(ArgumentDelimiter);
          return;
      }
      base.Translate(context, node, section, position);
    }

    /// <inheritdoc/>
    public override void Translate(SqlCompilerContext context, SqlNextValue node, NodeSection section) =>
      throw new NotSupportedException(Strings.ExDoesNotSupportSequences);

    /// <inheritdoc/>
    public override void Translate(SqlCompilerContext context, SqlCast node, NodeSection section)
    {
      var output = context.Output;
      var sqlType = node.Type.Type;

      if (sqlType == SqlType.Binary ||
        sqlType == SqlType.Char ||
        sqlType == SqlType.Interval ||
        sqlType == SqlType.DateTime) {
        _ = section switch {
          NodeSection.Entry => output.Append("CAST("),
          NodeSection.Exit => output.Append("AS ").Append(Translate(node.Type)).Append(")"),
          _ => throw new ArgumentOutOfRangeException("section"),
        };
      }
      else if (sqlType == SqlType.Int16 || sqlType == SqlType.Int32) {
        _ = section switch {
          NodeSection.Entry => output.Append("CAST("),
          NodeSection.Exit => output.Append("AS SIGNED ").Append(Translate(node.Type)).Append(")"),
          _ => throw new ArgumentOutOfRangeException(nameof(section)),
        };
      }
      else if (sqlType == SqlType.Decimal) {
        _ = section switch {
          NodeSection.Entry => output.Append("CAST("),
          NodeSection.Exit => output.Append("AS ").Append(Translate(node.Type)).Append(")"),
          _ => throw new ArgumentOutOfRangeException(nameof(section)),
        };
      }
      else if (sqlType == SqlType.Decimal ||
        sqlType == SqlType.Double ||
        sqlType == SqlType.Float) {
        switch (section) {
          case NodeSection.Entry:
          case NodeSection.Exit:
            break;
          default:
            throw new ArgumentOutOfRangeException(nameof(section));
        }
      }
    }

    /// <inheritdoc/>
    public override string Translate(SqlDateTimePart part)
    {
      return part switch {
        SqlDateTimePart.Millisecond => "MICROSECOND",
        SqlDateTimePart.Day => "DAY",
        SqlDateTimePart.Year => "YEAR",
        SqlDateTimePart.Month => "MONTH",
        SqlDateTimePart.Hour => "HOUR",
        SqlDateTimePart.Minute => "MINUTE",
        _ => base.Translate(part),
      };
    }

    /// <inheritdoc/>
    public override string Translate(SqlLockType lockType)
    {
      if (lockType.Supports(SqlLockType.Shared)) {
        return "LOCK IN SHARE MODE";
      }

      return lockType.Supports(SqlLockType.SkipLocked) || lockType.Supports(SqlLockType.ThrowIfLocked)
        ? base.Translate(lockType)
        : "FOR UPDATE";
    }

    //----------------------- Other Vendor Type MySQL Type
    //BOOL TINYINT
    //BOOLEAN TINYINT
    //CHARACTER VARYING(M) VARCHAR(M)
    //FIXED DECIMAL
    //FLOAT4 FLOAT
    //FLOAT8 DOUBLE
    //INT1 TINYINT
    //INT2 SMALLINT
    //INT3 MEDIUMINT
    //INT4 INT
    //INT8 BIGINT
    //LONG VARBINARY MEDIUMBLOB
    //LONG VARCHAR MEDIUMTEXT
    //LONG MEDIUMTEXT
    //MIDDLEINT MEDIUMINT
    //NUMERIC DECIMAL
    protected virtual string TranslateClrType(Type type)
    {
      switch (Type.GetTypeCode(type)) {
        case TypeCode.Boolean:
          return "bool";
        case TypeCode.Byte:
        case TypeCode.SByte:
        case TypeCode.Int16:
          return "int2";
        case TypeCode.UInt16:
        case TypeCode.Int32:
          return "int4";
        case TypeCode.UInt32:
        case TypeCode.Int64:
          return "int8";
        case TypeCode.UInt64:
        case TypeCode.Decimal:
          return "numeric";
        case TypeCode.Single:
          return "float4";
        case TypeCode.Double:
          return "float8";
        case TypeCode.Char:
        case TypeCode.String:
          return "text";
        case TypeCode.DateTime:
          return "timestamp";
        default:
          if (type==typeof (TimeSpan)) {
            return "numeric";
          }
          return "text";
      }
    }

    public virtual void Translate(SqlCompilerContext context, SqlRenameColumn action) //TODO: Work on this.
    {
      string schemaName = action.Column.Table.Schema.DbName;
      string tableName = action.Column.Table.DbName;
      string columnName = action.Column.DbName;

      //alter table `actor` change column last_name1 last_name varchar(45)

      var output = context.Output;
      _ = output.Append("ALTER TABLE ");
      TranslateIdentifier(output, tableName);
      _ = output.Append(" CHANGE COLUMN ");
      TranslateIdentifier(output, columnName);
      _ = output.AppendSpaceIfNecessary();
      TranslateIdentifier(output, action.NewName);
      _ = output.AppendSpaceIfNecessary()
        .Append(Translate(action.Column.DataType));
    }

    // Constructors

    public Translator(SqlDriver driver)
      : base(driver)
    {
    }
  }
}